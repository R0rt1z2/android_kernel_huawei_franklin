#include "../huawei_audio/yor/huawei_mt6359_accdet.dtsi"

/* Box ID BEGIN */
&pio {
	speaker_box_on: speaker_box_on {
		pins_cmd_dat {
			pinmux = <PINMUX_GPIO190__FUNC_GPIO190>;
			slew-rate = <0>;
			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
		};
	};
	speaker_box_off: speaker_box_off {
		pins_cmd_dat {
			pinmux = <PINMUX_GPIO190__FUNC_GPIO190>;
			slew-rate = <0>;
			bias-disable;
		};
	};
};

&deviceboxID {
	compatible = "huawei,deviceboxID";
	pinctrl-names = "default", "idle";
	pinctrl-0 = <&speaker_box_on>;
	pinctrl-1 = <&speaker_box_off>;
	check_mode = "gpio";
	box_num = <2>;
	enable_boxID = <1 0 0 0>;
	gpio_num = <1 0 0 0>;
	gpio_speakerID = <&pio 190 0>;
	speaker_map = <6 1>;
	status = "ok";
};
/* Box ID END */

&audio_hw_config {
	product_name = "mt6885";
	mic_silence_continuous_check_times = "5";
	speaker_test_content = "speaker";
	rcv_use_i2s = "false";
	audio_param_path = "odm/etc/audio/audio_param";
	audio_param_ce_path = "odm/etc/audio/audio_param_ce";
	record_algo_version = "record5_0";
	is_huawei_record = "true";
	multi_mic_enable = "true";
	third_platform_name = "mt6885";
	third_audio_hal_name = "audio.primary.mt6885.so";
	audio_channel_rotation_info {
		swap_thread = "25";
		angle = "90";
		rotation_support = "true";
	};
	audio_capability {
		backmic_record_enable = "true";
		asr_vibrate_support = "true";
		/*
		sound trigger feature.
		false: this product doesn't support soundtrigger feature.
		2.0: this product supports the twice wakeup feature.
		*/
		soundtrigger_version = "2.0";
		soundtrigger_enhance_enable = "true";
		soundtrigger_mic_info = "3";
		/*
		bit0: node 900 optimization,  1:enab1e
		bit1:
			0: e2e disable
			1: e2e enable, must use hifi_6405_virtual_btn_devkit.img
		*/
		soundtrigger_kws1_feature = "2";
		/*
		max stream volume to replace Android default volume.
		*/
		/*
		use hisilicon wakeup engine.
		true: use hisilicon wakeup engine.
		false: DO NOT use hisilicon wakeup engine.
		*/
		wakeup_hisiengine = "true";
		asr_enhance_mic_choose = "1";
	};
};

&ana_hs {
	compatible = "huawei,ana_hs";
	status = "ok";
	ana_hs_core@0 {
		compatible = "huawei,ana_hs_core";
		bus_type = <0>; /* 0: gpio,  1: i2c */

		/* if use gpio */
		gpio_num = <1>;
		gpio_type = <0>; /* 0: SOC,  1: codec */
		gpios = <&pio 29 0>;
		gpio_init_val = <0>;  /* 0: output low, 1: output high */

		/* plug_out sequence */
		plug_out_seq = <
			0 0 0 0
		>;
		/* mic_gnd_switch used gpio */
		mic_gnd_sequence = <
			0 0 0 150
		>;
		/* switch ana_hs usb using ldo */
		regulator_used;
		ana_hs_switch-supply = <&mt_pmic_vmc_ldo_reg>;
		ana_hs_switch_vol = <3300000>;
		status = "ok";
	};
};

&sound {
		mtk_spk_i2s_out = <3>;
		mtk_spk_i2s_in = <9>; /* 9 means 32bit, 0 means 24bit */
};

/* feature : $enable $dl_mem $ul_mem $ref_mem $size */
&snd_audio_dsp {
	compatible = "mediatek,snd_audio_dsp";
	mtk_dsp_voip = <0x7 0x1 0xffffffff 0xffffffff 0x30000>;
	mtk_dsp_primary = <0x7 0x0 0xffffffff 0xffffffff 0x30000>;
	mtk_dsp_offload = <0x0 0x6 0xffffffff 0xffffffff 0x400000>;
	mtk_dsp_deep = <0x0 0x3 0xffffffff 0xffffffff 0x30000>;
	mtk_dsp_playback = <0x1 0x4 0x10 0x14 0x30000>;
	mtk_dsp_music = <0x1 0xffffffff 0xffffffff 0xffffffff 0x0>;
	mtk_dsp_capture1 = <0x0 0xffffffff 0xd 0x13 0x20000>;
	mtk_dsp_a2dp = <0x0 0xffffffff 0xffffffff 0xffffffff 0x40000>;
	mtk_dsp_dataprovider = <0x0 0xffffffff 0xf 0xffffffff 0x30000>;
	mtk_dsp_call_final = <0x7 0x0 0x10 0x14 0x18000>;
	mtk_dsp_fast = <0x7 0x2 0xffffffff 0xffffffff 0x5000>;
	mtk_dsp_ktv = <0x1 0x8 0x12 0xffffffff 0x10000>;
	mtk_dsp_ver = <0x1>;
	swdsp_smartpa_process_enable = <0x7>;
	mtk_dsp_mem_afe = <0x1 0x40000>; /* always enable */
};

&i2c9 {
	smartpa@30{
		compatible = "huawei,smartpakit_i2c";
		reg = <0x30>;
		/* 4:huawei customize */
		chip_vendor = <4>;
		/* refer to smartpakit.out_device prop */
		chip_id = <0>;
		chip_model = "06-01";
		/* maybe trigger one irq after some chip reset
		 * debounce wait time unit: msecs */
		reset_debounce_wait_time = <100>;
		status = "ok";

		/* reg_ctl node: a node contains three data<addr value ctl_type>
		 * ctl_type: 0 read reg(default), 1 write reg, 2 only time delay
		 * value:
		 *     read:  reg number(num >= 1)
		 *     write: reg value
		 *     delay: time delay
		 * time delay unit: msecs
		 */
		version_regs = <0x00 1 0>;
		dump_regs = <0 256 0>;

		hw_reset {
			gpio_reset = <&pio 30 0>;
			/* gpio_state node: a node contains two data<state delay>
			 * time delay unit: msecs
			 */
			ctl_sequence = <0 1 1 1>;
		};

		irq_handler {
			gpio_irq = <&pio 31 0>;
			/* 0x0 IRQF_TRIGGER_NONE, 0x1 IRQF_TRIGGER_RISING, 0x2 IRQF_TRIGGER_FALLING, 0x4 IRQF_TRIGGER_HIGH, 0x8 IRQF_TRIGGER_LOW */
			irq_flags = <2>;
			/* whether or not need reset chip */
			need_reset;
			rw_sequence = <
				0x00 8 0
				0x09 5 0
				0x12 3 0
				0x60 2 0
				0x78 1 0
				0x7a 1 0
			>;
		};

		regmap_cfg {
			reg_bits = <8>;
			val_bits = <16>;
			/* 0 REGCACHE_NONE, 1 REGCACHE_RBTREE, 2 REGCACHE_COMPRESSED, 3 REGCACHE_FLAT */
			cache_type = <0>;
			max_register = <0xff>;
		};
	};

	smartpa@34{
		compatible = "huawei,smartpakit_i2c";
		reg = <0x34>;
		/* 4:huawei customize */
		chip_vendor = <4>;
		/* refer to smartpakit.out_device prop */
		chip_id = <0>;
		chip_model = "01-02";
		status = "ok";

		/* reg_ctl node: a node contains three data<addr value ctl_type>
		 * ctl_type: 0 read reg(default), 1 write reg, 2 only time delay
		 * value:
		 *     read:  reg number(num >= 1)
		 *     write: reg value
		 *     delay: time delay
		 * time delay unit: msecs */
		version_regs = <0x03 1 0>;
		dump_regs = <0 256 0>;
		hw_reset {
			gpio_reset = <&pio 30 0>;
			/* gpio_state node: a node contains two data<state delay>
			 * time delay unit: msecs */
			ctl_sequence = <1 1 0 1>;
		};
		irq_handler {
			gpio_irq = <&pio 31 0>;
			/* 0x0 IRQF_TRIGGER_NONE, 0x1 IRQF_TRIGGER_RISING, 0x2 IRQF_TRIGGER_FALLING, 0x4 IRQF_TRIGGER_HIGH, 0x8 IRQF_TRIGGER_LOW */
			irq_flags = <2>;
			/* whether or not need reset chip */
			need_reset;
			rw_sequence = <
				0x10 1 0
				0x11 1 0
				0x13 1 0
				0x14 1 0
				0x40 1 0
				0x41 1 0
				0x42 1 0
			>;
		};
		regmap_cfg {
			reg_bits = <8>;
			val_bits = <16>;
			/* 0 REGCACHE_NONE, 1 REGCACHE_RBTREE, 2 REGCACHE_COMPRESSED, 3 REGCACHE_FLAT */
			cache_type = <0>;
			max_register = <0xff>;
			reg_defaults = <
				0x00 0x1801
				0x01 0x0014
			>;
		};
	};

	smartpa@50{
		compatible = "huawei,smartpakit_i2c";
		reg = <0x50>;
		/* 4:huawei customize */
		chip_vendor = <4>;
		/* refer to smartpakit.out_device prop */
		chip_id = <0>;
		chip_model = "03-01";
		status = "ok";

		/* reg_ctl node: a node contains three data<addr value ctl_type>
		 * ctl_type: 0 read reg(default), 1 write reg, 2 only time delay
		 * value:
		 *     read:  reg number(num >= 1)
		 *     write: reg value
		 *     delay: time delay
		 * time delay unit: msecs */
		version_regs = <0x0 1 0>;
		dump_regs = <
			0x000000 1          0
			0x000008 1          0
			0x002014 0x21       0
			0x002400 1          0
			0x002c04 0xd        0
			0x003800 0x31       0
			0x004004 1          0
			0x004220 1          0
			0x004300 1          0
			0x004800 0x3d       0
			0x004C00 1          0
			0x004C20 0x15       0
			0x006000 1          0
			0x006404 0x11       0
			0x006450 1          0
			0x006800 0x9        0
			0x006C04 1          0
			0xd00000 0x4d       0
			0xe02800 1          0>;

		hw_reset {
			gpio_reset = <&pio 30 0>;
			/* gpio_state node: a node contains two data<state delay>
			 * time delay unit: msecs */
			ctl_sequence = <1 1 0 1>;
		};
		irq_handler {
			gpio_irq = <&pio 31 0>;
			/* 0x0 IRQF_TRIGGER_NONE, 0x1 IRQF_TRIGGER_RISING, 0x2 IRQF_TRIGGER_FALLING, 0x4 IRQF_TRIGGER_HIGH, 0x8 IRQF_TRIGGER_LOW */
			irq_flags = <2>;
			/* whether or not need reset chip */
			need_reset;
			rw_sequence = <
				0xd00020 1          0
				0xd00024 1          0
				0xd00028 1          0
				0xd0002c 1          0
				0xd00000 0xffffffff 1
				0xd00004 0xffffffff 1
				0xd00008 0xffffffff 1
				0xd0000c 0xffffffff 1
			>;
		};
		regmap_cfg {
			reg_bits = <32>;
			val_bits = <32>;
			/* 0 REGCACHE_NONE, 1 REGCACHE_RBTREE, 2 REGCACHE_COMPRESSED, 3 REGCACHE_FLAT */
			cache_type = <0>;
			max_register = <0xe0ffff>;
		};
	};
};

&smartpakit {
	compatible = "huawei,smartpakit";
	/* 0 hisi, 1 qcom, 2 mtk */
	soc_platform = <2>;
	/* algo running on: 0 codec_dsp, 1 soc_dsp, 2 smartpa_dsp, 3 simple pa(not smpartpa), 4 simple pa(with i2c) */
	algo_in = <1>;
	/* algo_in params need match out_device for smartpa.
	 * Now, up to only support four pa, so out_device = <0 0 0 0>;
	 * 1. This array is arranged in the following order:
	 *    <0 1 2 3>
	 *    <pril prir secl secr>
	 * 2. This array element value is 0 or 1:
	 *    smartpa: 0 speaker, 1 receiver
	 *    simple pa: out_device not applicable, only set 0 to indicate pa_num
	 * 3. The length of this array is variable, for example:
	 *    single pa: out_device = <0>;
	 *    two pa: out_device = <0 0>;
	 *    four pa: out_device = <1 1 0 0>; */
	out_device = <0>;
	/* param_version: 1 mixed smartpa param support */
	param_version = <1>;
	misc_rw_permission_enable;
	status = "ok";
};
