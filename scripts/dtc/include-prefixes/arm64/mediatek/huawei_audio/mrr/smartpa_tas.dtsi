&i2c9 {
			#address-cells = <1>;
			#size-cells = <0>;
			smartpa@4C {
				compatible = "huawei,smartpakit_i2c";
				reg = <0x4C>;
				/* 0 MAXIM, 1 NXP, 2 TI, 3 OTHER, 4:huawei customize */
				chip_vendor = <4>;
				/* refer to smartpakit.out_device prop */
				chip_id = <0>;
				chip_model = "02-01";
				/* maybe trigger one irq after some chip reset, ext. tas2560
				* debounce wait time unit: msecs */
				reset_debounce_wait_time = <200>;
				sync_irq_debounce_time;
				status = "okay";

				/* reg_ctl node: a node contains three data<addr value ctl_type>
				* ctl_type: 0 read reg(default), 1 write reg, 2 only time delay
				* value:
				*     read:  reg number(num >= 1)
				*     write: reg value
				*     delay: time delay
				* time delay unit: msecs */
				version_regs = <
					0	0	1
					125	1	0
					>;
				dump_regs = <
					0	0	1
					0	128	0
					0	50	1
					0	128	0
					0	51	1
					0	128	0
					0	52	1
					0	128	0
				>;
				hw_reset {
					gpio_reset = <&pio 30 0>; /* GPIO 30 */
					/* gpio_state node: a node contains two data<state delay>
					* time delay unit: msecs */
					ctl_sequence = <0 3 1 2>;
				};

				irq_handler {
					gpio_irq = <&pio 31 0>; /* GPIO 31 */
					/* 0x0 IRQF_TRIGGER_NONE, 0x1 IRQF_TRIGGER_RISING, 0x2 IRQF_TRIGGER_FALLING, 0x4 IRQF_TRIGGER_HIGH, 0x8 IRQF_TRIGGER_LOW*/
					irq_flags = <2>;
					/* whether or not need reset chip*/
					need_reset;
					need_filter_irq;
					rw_sequence = <
						0	20	2
						0	0	1
						26	1	0
						27	1	0
						31	1	0
						32	1	0
						36	1	0
						37	1	0
						2	1	0
						120	1	0
					>;
				};

				regmap_cfg {
					reg_bits = <8>;
					val_bits = <8>;
					/* 0 REGCACHE_NONE, 1 REGCACHE_RBTREE, 2 REGCACHE_COMPRESSED, 3 REGCACHE_FLAT */
					cache_type = <0>;
					max_register = <128>;
				};
			};

			smartpa@4D {
				compatible = "huawei,smartpakit_i2c";
				reg = <0x4D>;
				/* 0 MAXIM, 1 NXP, 2 TI, 3 OTHER, 4:huawei customize */
				chip_vendor = <4>;
				/* refer to smartpakit.out_device prop */
				chip_id = <1>;
				chip_model = "02-01";
				/* maybe trigger one irq after some chip reset, ext. tas2560
				* debounce wait time unit: msecs */
				reset_debounce_wait_time = <200>;
				sync_irq_debounce_time;
				status = "okay";

				/* reg_ctl node: a node contains three data<addr value ctl_type>
				* ctl_type: 0 read reg(default), 1 write reg, 2 only time delay
				* value:
				*     read:  reg number(num >= 1)
				*     write: reg value
				*     delay: time delay
				* time delay unit: msecs */
				version_regs = <
					0	0	1
					125	1	0
					>;
				dump_regs = <
					0	0	1
					0	128	0
					0	50	1
					0	128	0
					0	51	1
					0	128	0
					0	52	1
					0	128	0
				>;
				hw_reset {
					gpio_reset = <&pio 30 0>; /* GPIO 30 */
					/* gpio_state node: a node contains two data<state delay>
					* time delay unit: msecs */
					ctl_sequence = <0 3 1 2>;
				};

				irq_handler {
					gpio_irq = <&pio 83 0>; /* GPIO 83 */
					/* 0x0 IRQF_TRIGGER_NONE, 0x1 IRQF_TRIGGER_RISING, 0x2 IRQF_TRIGGER_FALLING, 0x4 IRQF_TRIGGER_HIGH, 0x8 IRQF_TRIGGER_LOW*/
					irq_flags = <2>;
					/* whether or not need reset chip*/
					need_reset;
					need_filter_irq;
					rw_sequence = <
						0	20	2
						0	0	1
						26	1	0
						27	1	0
						31	1	0
						32	1	0
						36	1	0
						37	1	0
						2	1	0
						120	1	0
					>;
				};

				regmap_cfg {
					reg_bits = <8>;
					val_bits = <8>;
					/* 0 REGCACHE_NONE, 1 REGCACHE_RBTREE, 2 REGCACHE_COMPRESSED, 3 REGCACHE_FLAT */
					cache_type = <0>;
					max_register = <128>;
				};
			};

			smartpa@4E {
				compatible = "huawei,smartpakit_i2c";
				reg = <0x4E>;
				/* 0 MAXIM, 1 NXP, 2 TI, 3 OTHER, 4:huawei customize */
				chip_vendor = <4>;
				/* refer to smartpakit.out_device prop */
				chip_id = <2>;
				chip_model = "02-01";
				/* maybe trigger one irq after some chip reset, ext. tas2560
				* debounce wait time unit: msecs */
				reset_debounce_wait_time = <200>;
				sync_irq_debounce_time;
				status = "okay";

				/* reg_ctl node: a node contains three data<addr value ctl_type>
				* ctl_type: 0 read reg(default), 1 write reg, 2 only time delay
				* value:
				*     read:  reg number(num >= 1)
				*     write: reg value
				*     delay: time delay
				* time delay unit: msecs */
				version_regs = <
					0	0	1
					125	1	0
					>;
				dump_regs = <
					0	0	1
					0	128	0
					0	50	1
					0	128	0
					0	51	1
					0	128	0
					0	52	1
					0	128	0
				>;
				hw_reset {
					gpio_reset = <&pio 30 0>; /* GPIO 30 */
					/* gpio_state node: a node contains two data<state delay>
					* time delay unit: msecs */
					ctl_sequence = <0 3 1 2>;
				};

				irq_handler {
					gpio_irq = <&pio 194 0>; /* GPIO 194 */
					/* 0x0 IRQF_TRIGGER_NONE, 0x1 IRQF_TRIGGER_RISING, 0x2 IRQF_TRIGGER_FALLING, 0x4 IRQF_TRIGGER_HIGH, 0x8 IRQF_TRIGGER_LOW*/
					irq_flags = <2>;
					/* whether or not need reset chip*/
					need_reset;
					need_filter_irq;
					rw_sequence = <
						0	20	2
						0	0	1
						26	1	0
						27	1	0
						31	1	0
						32	1	0
						36	1	0
						37	1	0
						2	1	0
						120	1	0
					>;
				};

				regmap_cfg {
					reg_bits = <8>;
					val_bits = <8>;
					/* 0 REGCACHE_NONE, 1 REGCACHE_RBTREE, 2 REGCACHE_COMPRESSED, 3 REGCACHE_FLAT */
					cache_type = <0>;
					max_register = <128>;
				};
			};

			smartpa@4F {
				compatible = "huawei,smartpakit_i2c";
				reg = <0x4F>;
				/* 0 MAXIM, 1 NXP, 2 TI, 3 OTHER, 4:huawei customize */
				chip_vendor = <4>;
				/* refer to smartpakit.out_device prop */
				chip_id = <3>;
				chip_model = "02-01";
				/* maybe trigger one irq after some chip reset, ext. tas2560
				* debounce wait time unit: msecs */
				reset_debounce_wait_time = <200>;
				sync_irq_debounce_time;
				status = "okay";

				/* reg_ctl node: a node contains three data<addr value ctl_type>
				* ctl_type: 0 read reg(default), 1 write reg, 2 only time delay
				* value:
				*     read:  reg number(num >= 1)
				*     write: reg value
				*     delay: time delay
				* time delay unit: msecs */
				version_regs = <
					0	0	1
					125	1	0
					>;
				dump_regs = <
					0	0	1
					0	128	0
					0	50	1
					0	128	0
					0	51	1
					0	128	0
					0	52	1
					0	128	0
				>;
				hw_reset {
					gpio_reset = <&pio 30 0>; /* GPIO 30 */
					/* gpio_state node: a node contains two data<state delay>
					* time delay unit: msecs */
					ctl_sequence = <0 3 1 2>;
				};

				irq_handler {
					gpio_irq = <&pio 73 0>; /* GPIO 73 */
					/* 0x0 IRQF_TRIGGER_NONE, 0x1 IRQF_TRIGGER_RISING, 0x2 IRQF_TRIGGER_FALLING, 0x4 IRQF_TRIGGER_HIGH, 0x8 IRQF_TRIGGER_LOW*/
					irq_flags = <2>;
					/* whether or not need reset chip*/
					need_reset;
					need_filter_irq;
					rw_sequence = <
						0	20	2
						0	0	1
						26	1	0
						27	1	0
						31	1	0
						32	1	0
						36	1	0
						37	1	0
						2	1	0
						120	1	0
					>;
				};

				regmap_cfg {
					reg_bits = <8>;
					val_bits = <8>;
					/* 0 REGCACHE_NONE, 1 REGCACHE_RBTREE, 2 REGCACHE_COMPRESSED, 3 REGCACHE_FLAT */
					cache_type = <0>;
					max_register = <128>;
				};
			};
};
